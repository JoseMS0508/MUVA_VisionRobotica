---
title: "Pr√°ctica 2: Reconstrucci√≥n 3D Est√©reo paso a paso"
date: 2025-04-13
categories: [Reconstrucci√≥n, Est√©reo]
tags: [Triangulaci√≥n, Computer-Vision, HAL]
layout: single
author_profile: false
---

## ‚ú® Objetivo

En esta pr√°ctica me propuse desarrollar un sistema b√°sico de reconstrucci√≥n 3D utilizando visi√≥n est√©reo. La idea era aplicar conceptos como la detecci√≥n de bordes, b√∫squeda de correspondencias en l√≠neas epipolares y triangulaci√≥n, utilizando las herramientas proporcionadas por la API de HAL y la interfaz gr√°fica de GUI.

---

## üß† Enfoque general

La reconstrucci√≥n se basa en el principio de que si se puede identificar un mismo punto en dos im√°genes (izquierda y derecha), y se conoce la posici√≥n de las c√°maras, entonces es posible calcular su posici√≥n 3D mediante geometr√≠a.

El procedimiento lo divid√≠ en tres grandes bloques:

---

### 1. Detecci√≥n de puntos de inter√©s (bordes)

En lugar de buscar keypoints complejos (como SIFT o ORB), opt√© por una estrategia m√°s controlada: usar Canny para detectar bordes y despu√©s filtrar los resultados con un suavizado bilateral. Esto me permite asegurar que solo trabajo con bordes significativos, evitando ruido.

Selecciono puntos de borde de la imagen izquierda cada N p√≠xeles para no sobrecargar el sistema, y adem√°s para mantener un rendimiento aceptable en la visualizaci√≥n.

---

### 2. Matching: b√∫squeda de correspondencias est√©reo

Para cada punto detectado en la imagen izquierda, busco su correspondencia en la imagen derecha, restringiendo la b√∫squeda a su l√≠nea epipolar (es decir, misma coordenada Y). Esto simplifica mucho el proceso y es coherente con la configuraci√≥n est√©reo horizontal.

Uso correlaci√≥n de ventanas (template matching) para comparar la regi√≥n alrededor del punto en la imagen izquierda con diferentes posiciones en la derecha. Para evitar comparaciones innecesarias, solo lo hago sobre p√≠xeles que tambi√©n son bordes en la imagen derecha.

Solo acepto una correspondencia si la similitud (correlaci√≥n) supera un cierto umbral, lo que ayuda a descartar falsos positivos.

---

### 3. Triangulaci√≥n y visualizaci√≥n

Una vez tengo los puntos correspondientes en ambas im√°genes, utilizo la API de HAL para:

- Transformar las coordenadas gr√°ficas en coordenadas √≥pticas
- Obtener las retroproyecciones 3D desde cada c√°mara

Con esto, genero dos rayos en el espacio (uno por cada c√°mara) y calculo su punto medio m√°s cercano, asumiendo que la intersecci√≥n exacta es poco probable debido al ruido. Este punto medio es el que tomo como resultado de la triangulaci√≥n.

Finalmente, a√±ado cada punto a la nube de puntos 3D que se va mostrando con `GUI.ShowNewPoints()`. Tambi√©n dibujo las correspondencias con `GUI.showImageMatching()` para ir viendo el proceso.

---

## üéØ Resultados

El sistema consigue generar puntos 3D con color bastante estables y visualizarlos en tiempo real. Aunque el m√©todo es bastante b√°sico, es efectivo para comprender todo el pipeline est√©reo desde la imagen 2D hasta la reconstrucci√≥n en el espacio.

Este ejercicio me ha servido mucho para interiorizar los conceptos de proyecci√≥n, correspondencia y triangulaci√≥n, especialmente al ver los errores que surgen cuando el matching falla o la triangulaci√≥n es degenerada.

---
